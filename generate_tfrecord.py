""" Sample TensorFlow XML-to-TFRecord converter

usage: generate_tfrecord.py [-h] [-x XML_DIR] [-l LABELS_PATH] [-o OUTPUT_PATH] [-i IMAGE_DIR] [-c CSV_PATH]

optional arguments:
  -h, --help            show this help message and exit
  -x XML_DIR, --xml_dir XML_DIR
                        Path to the folder where the input .xml files are stored.
  -l LABELS_PATH, --labels_path LABELS_PATH
                        Path to the labels (.pbtxt) file.
  -o OUTPUT_PATH, --output_path OUTPUT_PATH
                        Path of output TFRecord (.record) file.
  -i IMAGE_DIR, --image_dir IMAGE_DIR
                        Path to the folder where the input image files are stored. Defaults to the same directory as XML_DIR.
  -c CSV_PATH, --csv_path CSV_PATH
                        Path of output .csv file. If none provided, then no file will be written.
"""

import os
import glob
import numpy as np
import pandas as pd
import io
import xml.etree.ElementTree as ET
import argparse

os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'    # Suppress TensorFlow logging (1)
import tensorflow.compat.v1 as tf_compat
import tensorflow as tf

from PIL import Image
from object_detection.utils import dataset_util, label_map_util
from collections import namedtuple
import albumentations as A
import matplotlib.pyplot as plt

# Initiate argument parser
parser = argparse.ArgumentParser(
    description="Sample TensorFlow XML-to-TFRecord converter")
parser.add_argument("-x",
                    "--xml_dir",
                    help="Path to the folder where the input .xml files are stored.",
                    type=str)
parser.add_argument("-l",
                    "--labels_path",
                    help="Path to the labels (.pbtxt) file.", type=str)
parser.add_argument("-o",
                    "--output_path",
                    help="Path of output TFRecord (.record) file.", type=str)
parser.add_argument("-i",
                    "--image_dir",
                    help="Path to the folder where the input image files are stored. "
                         "Defaults to the same directory as XML_DIR.",
                    type=str, default=None)
parser.add_argument("-c",
                    "--csv_path",
                    help="Path of output .csv file. If none provided, then no file will be "
                         "written.",
                    type=str, default=None)
parser.add_argument("-e",
                    "--img_extension",
                    help="Extension of the images. jpg or jpeg",
                    type=str, default="jpeg")
parser.add_argument("--augment",
                    help="Whether to augment the dataset or not",
                    dest="augment",
                    action="store_true")
parser.add_argument("--no-augment",
                    dest="augment",
                    action="store_false")
parser.set_defaults(augment=False)


args = parser.parse_args()

if args.image_dir is None:
    args.image_dir = args.xml_dir

label_map = label_map_util.load_labelmap(args.labels_path)
label_map_dict = label_map_util.get_label_map_dict(label_map)


def xml_to_csv(path):
    """Iterates through all .xml files (generated by labelImg) in a given directory and combines
    them in a single Pandas dataframe.

    Parameters:
    ----------
    path : str
        The path containing the .xml files
    Returns
    -------
    Pandas DataFrame
        The produced dataframe
    """

    xml_list = []
    for xml_file in glob.glob(path + '/*.xml'):
        tree = ET.parse(xml_file)
        root = tree.getroot()
        for member in root.findall('object'):
            img_name = root.find('filename').text
            if args.img_extension == "jpg" and (img_name.find("jpeg") != -1):
                img_name = img_name[:-4] + "jpg"
            elif args.img_extension == "jpeg" and (img_name.find("jpg") != -1):
                img_name = img_name[:-3] + "jpeg"
            else:
                pass
            value = (img_name,
                     int(root.find('size')[0].text),
                     int(root.find('size')[1].text),
                     member[0].text,
                     int(member[4][0].text),
                     int(member[4][1].text),
                     int(member[4][2].text),
                     int(member[4][3].text)
                     )
            xml_list.append(value)
    column_name = ['filename', 'width', 'height',
                   'class', 'xmin', 'ymin', 'xmax', 'ymax']
    xml_df = pd.DataFrame(xml_list, columns=column_name)
    return xml_df


def class_text_to_int(row_label):
    return label_map_dict[row_label]


def split(df, group):
    data = namedtuple('data', ['filename', 'object'])
    gb = df.groupby(group)
    return [data(filename, gb.get_group(x)) for filename, x in zip(gb.groups.keys(), gb.groups)]


def read_img(group, path):
    with tf.io.gfile.GFile(os.path.join(path, '{}'.format(group.filename)), 'rb') as fid:
        encoded_jpg = fid.read()
    encoded_jpg_io = io.BytesIO(encoded_jpg)
    image = Image.open(encoded_jpg_io)
    width, height = image.size
    #print("ORIGINAL IMAGE: ", np.asarray(image))
    #print(encoded_jpg)
    return encoded_jpg, encoded_jpg_io, image, width, height


def calculate_bbox():
    pass


def structure_example(width, height, group, path):
    xmins = []
    xmaxs = []
    ymins = []
    ymaxs = []
    classes_text = []
    classes = []
    for index, row in group.object.iterrows():
        xmins.append(row['xmin'] / width)
        xmaxs.append(row['xmax'] / width)
        ymins.append(row['ymin'] / height)
        ymaxs.append(row['ymax'] / height)
        classes_text.append(row['class'].encode('utf8'))
        classes.append(class_text_to_int(row['class']))
    return xmins, xmaxs, ymins, ymaxs, classes_text, classes


def create_tf_example(encoded_jpg, image, width, height, xmins, xmaxs,
                      ymins, ymaxs, classes_text, classes, filename,
                      image_format):

    tf_example = tf.train.Example(features=tf.train.Features(feature={
        'image/height': dataset_util.int64_feature(height),
        'image/width': dataset_util.int64_feature(width),
        'image/filename': dataset_util.bytes_feature(filename),
        'image/source_id': dataset_util.bytes_feature(filename),
        'image/encoded': dataset_util.bytes_feature(encoded_jpg),
        'image/format': dataset_util.bytes_feature(image_format),
        'image/object/bbox/xmin': dataset_util.float_list_feature(xmins),
        'image/object/bbox/xmax': dataset_util.float_list_feature(xmaxs),
        'image/object/bbox/ymin': dataset_util.float_list_feature(ymins),
        'image/object/bbox/ymax': dataset_util.float_list_feature(ymaxs),
        'image/object/class/text': dataset_util.bytes_list_feature(classes_text),
        'image/object/class/label': dataset_util.int64_list_feature(classes),
    }))
    return tf_example


def augment_selector(classes_text, width, height):
    """
    crop = A.Compose([
        A.RandomCrop(width=450, height=450),
        A.RandomBrightnessContrast(p=0.2),
        A.VerticalFlip(p=0.5),
        A.VerticalFlip(p=0.5),
        
        ],
        bbox_params={"format": 'pascal_voc',
                     'label_fields': classes_text})
    h_flip = A.Compose([
        A.HorizontalFlip(p=0.5),
        A.RandomBrightnessContrast(p=0.2)],
        bbox_params={"format": 'pascal_voc',
                     'label_fields': classes_text})
    v_flip = A.Compose([
        
        A.RandomBrightnessContrast(p=0.2)],
        bbox_params={"format": 'pascal_voc',
                     'label_fields': classes_text})
    brightness = A.Compose([
        A.RandomBrightnessContrast(p=0.2)],
        bbox_params={"format": 'pascal_voc',
                     'label_fields': classes_text})
    """
    random_ratio = float(np.random.uniform(low=0.7, high=0.99))
    transform = A.Compose([
            #A.RandomSizedBBoxSafeCrop(width=int(width*random_ratio),
            #                          height=int(height*random_ratio),
            #                          erosion_rate=0.2),
            A.HorizontalFlip(p=0.3),
            A.RandomBrightnessContrast(p=0.2),
            A.VerticalFlip(p=0.3),
            A.GaussNoise(p=0.2),
            A.GaussianBlur(p=0.2),
            A.CLAHE(p=0.2),
            A.HueSaturationValue(p=0.2),  
            A.RandomSunFlare(p=0.2),
            A.RandomRain(p=0.2),
            A.RandomFog(p=0.2),],
        bbox_params=A.BboxParams(format='pascal_voc',
                                 label_fields=['classes_text']))
    
    #augment_dict = {
    #    "crop": crop,
    #    "h_flip": h_flip,
    #    "v_flip": v_flip,
    #    "brightness": brightness,
    #}

    return transform#augment_dict.get(augment_type)


def augment_pipeline(image, width, height, bboxes, classes_text,
                     group, path, filename, image_format,
                     augment_type="crop"):

    classes_text = [classes.decode("utf-8") for classes in classes_text]

    transform = augment_selector(classes_text,
                                 width, height)

    transformed = transform(image=np.asarray(image),
                            bboxes=bboxes,
                            classes_text=classes_text)
    #print(transformed)
    transformed_img = transformed["image"]
    transformed_img = Image.fromarray(transformed_img)
    buf = io.BytesIO()
    transformed_img.save(buf, format='JPEG')#image_format.decode("utf-8"))
    transformed_encoded_jpg = buf.getvalue()
    #print(type(transformed_img))
    #print(transformed_img.shape)
    #transformed_encoded_jpg = transformed_img["image"].tobytes()#tf.io.serialize_tensor(transformed_img).numpy()
    bboxes = np.array(transformed["bboxes"])
    #print(transformed["bboxes"])
    if len(bboxes):
        transformed_xmins = [float(xmin) for xmin in bboxes[:, 0]]
        transformed_ymins = [float(ymin) for ymin in bboxes[:, 1]]
        transformed_xmaxs = [float(xmax) for xmax in bboxes[:, 2]]
        transformed_ymaxs = [float(ymax) for ymax in bboxes[:, 3]]
        transformed_classes = [class_text_to_int(t_class) for t_class in transformed["classes_text"]]
        transformed_classes_text = [t_class.encode('utf-8') for t_class in transformed["classes_text"]]
    else:
        transformed_xmins = list()
        transformed_ymins = list()
        transformed_xmaxs = list()
        transformed_ymaxs = list()
        transformed_classes_text = list()
        transformed_classes = list()
    #transformed_xmins, transformed_ymins, transformed_xmaxs, transformed_ymaxs = transformed["bboxs"]
    #print(transformed["bboxs"])

    transformed_width, transformed_height = transformed_img.size

    return_dict = {
        "encoded_jpg": transformed_encoded_jpg,
        "image": transformed_img,
        "width": transformed_width,
        "height": transformed_height, 
        "xmins": transformed_xmins, 
        "xmaxs": transformed_xmaxs,
        "ymins": transformed_ymins, 
        "ymaxs": transformed_ymaxs, 
        "classes_text": transformed_classes_text, 
        "classes": transformed_classes, 
        "filename": filename,
        "image_format": image_format,
    }
    
    return return_dict #transformed_encoded_jpg, transformed_img, transformed_width, transformed_height, \
           #     transformed_xmins, transformed_xmaxs, transformed_ymins, transformed_ymaxs, \
           #        transformed_classes_text,  transformed_classes, filename, image_format


def main(_):

    writer = tf.io.TFRecordWriter(args.output_path)
    path = os.path.join(args.image_dir)
    examples = xml_to_csv(args.xml_dir)
    grouped = split(examples, 'filename')
    if args.augment:
        print("Data Augmentation will be performed.")
    else:
        print("Data Augmentation will not be performed.")
    #print(len(grouped))
    for group in grouped:
        encoded_jpg, encoded_jpg_io, image, width, height = read_img(group, path)
        xmins, xmaxs, ymins, ymaxs, classes_text, classes = structure_example(width, height, group, path)
        bboxs = list(zip(xmins, ymins, xmaxs, ymaxs, [class_text.decode("utf-8") for class_text in classes_text]))
        filename = group.filename.encode('utf8')
        image_format = bytes(args.img_extension, "utf-8")
        tf_example = create_tf_example(encoded_jpg, image, width, height,xmins, xmaxs,
                                       ymins, ymaxs, classes_text, classes, filename,
                                       image_format)
        writer.write(tf_example.SerializeToString())
        if args.augment:
            for augment_type in ["crop", "h_flip", "v_flip", "brightness"]:
                #print(augment_pipeline(image, width, height, bboxs, classes_text, 
                #                       group, path, filename, image_format,
                #                       augment_type=augment_type))
                tf_example = create_tf_example(**augment_pipeline(image, width,
                                                                  height, bboxs,
                                                                  classes_text, 
                                                                  group, path, 
                                                                  filename, 
                                                                  image_format,
                                                                  augment_type=augment_type))
                writer.write(tf_example.SerializeToString())
            
    writer.close()
    print('Successfully created the TFRecord file: {}'.format(args.output_path))
    if args.csv_path is not None:
        examples.to_csv(args.csv_path, index=None)
        print('Successfully created the CSV file: {}'.format(args.csv_path))


if __name__ == '__main__':
    tf_compat.app.run()
